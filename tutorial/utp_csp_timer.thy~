section {* FMI Timer (Simplified) *}

theory utp_csp_timer
  imports "../theories/utp_csp"
begin

type_synonym TIME = nat
  
datatype ch_timer = 
  setT TIME |
  updateSS TIME |
  step "TIME \<times> TIME" |
  endc
  
alphabet st_timer =
  currentTime :: TIME
  stepSize    :: TIME
  
type_synonym timer = "(st_timer, ch_timer) action"
  
definition Timer :: "TIME \<Rightarrow> TIME \<Rightarrow> TIME \<Rightarrow> timer" where
"Timer ct hc tN =
  (currentTime, stepSize) :=\<^sub>C (\<guillemotleft>ct\<guillemotright>, \<guillemotleft>hc\<guillemotright>) ;;
  (\<mu>\<^sub>C Step \<bullet> (setT?(t:\<guillemotleft>t\<guillemotright> <\<^sub>u \<guillemotleft>tN\<guillemotright>) \<^bold>\<rightarrow> currentTime :=\<^sub>C \<guillemotleft>t\<guillemotright>
           \<box> updateSS?(ss) \<^bold>\<rightarrow> stepSize :=\<^sub>C \<guillemotleft>ss\<guillemotright>
           \<box> step!(&currentTime)!(&stepSize) \<^bold>\<rightarrow>
               currentTime :=\<^sub>C min\<^sub>u(&currentTime + &stepSize, \<guillemotleft>tN\<guillemotright>)
           \<box> (&currentTime =\<^sub>u \<guillemotleft>tN\<guillemotright>) &\<^sub>u endc \<^bold>\<rightarrow> Stop) ;; Step)"

lemma csp_mu_unfold:
  "P is CSP \<Longrightarrow> (\<mu>\<^sub>C X \<bullet> P ;; X) = P ;; (\<mu>\<^sub>C X \<bullet> P ;; X)"
  apply (subst gfp_unfold)
   apply (simp_all add: closure Healthy_if)
done

  
lemma conj_conds: 
  "(P1 \<triangleleft> b \<triangleright> Q1 \<and> P2 \<triangleleft> b \<triangleright> Q2) = (P1 \<and> P2) \<triangleleft> b \<triangleright> (Q1 \<and> Q2)"
  by pred_auto

lemma disj_conds:
  "(P1 \<triangleleft> b \<triangleright> Q1 \<or> P2 \<triangleleft> b \<triangleright> Q2) = (P1 \<or> P2) \<triangleleft> b \<triangleright> (Q1 \<or> Q2)"
  by pred_auto
  
(*
thm conj_assoc
  
lemma tr'_eq_tr_simps [simp]: 
  "(P \<and> $tr\<acute> =\<^sub>u $tr) = ($tr\<acute> =\<^sub>u $tr \<and> P)"
  "(P \<and> ($tr\<acute> =\<^sub>u $tr \<and> Q)) = ($tr\<acute> =\<^sub>u $tr \<and> P \<and> Q)"
  "(($tr\<acute> =\<^sub>u $tr \<and> P) \<or> ($tr\<acute> =\<^sub>u $tr \<and> Q)) = ($tr\<acute> =\<^sub>u $tr \<and> (P \<or> Q))"
  "($tr\<acute> =\<^sub>u $tr \<and> ($tr\<acute> =\<^sub>u $tr \<and> P)) =($tr\<acute> =\<^sub>u $tr \<and> P)"
  by (rel_auto)+
  
lemma [simp]: 
  "(P1 \<triangleleft> b \<triangleright> Q1 \<and> P2 \<triangleleft> b \<triangleright> Q2) = (P1 \<and> P2) \<triangleleft> b \<triangleright> (Q1 \<and> Q2)"
  "(P1 \<triangleleft> b \<triangleright> Q1 \<or> P2 \<triangleleft> b \<triangleright> Q2) = (P1 \<or> P2) \<triangleleft> b \<triangleright> (Q1 \<or> Q2)"
  by (rel_auto)+
  
lemma [simp]: "(P \<triangleleft> b \<triangleright> Q) \<triangleleft> b \<triangleright> R = P \<triangleleft> b \<triangleright> R"
  by (rel_auto)

lemma [simp]: "P \<triangleleft> b \<triangleright> (Q \<triangleleft> b \<triangleright> R) = P \<triangleleft> b \<triangleright> R"
  by (rel_auto)

lemma [simp]: "P \<triangleleft> b \<triangleright> (b \<and> Q) = (b \<and> P)"
  by (rel_auto)

lemma [simp]: "P \<triangleleft> b \<triangleright> (b \<and> Q \<or> R) = P \<triangleleft> b \<triangleright> R"
  by (rel_auto)
    
lemma [simp]: "P \<triangleleft> b \<triangleright> (Q \<triangleleft> c \<triangleright> b) = P \<triangleleft> b \<triangleright> (c \<and> Q)"
  by (rel_auto)
    
lemma [simp]: "P \<triangleleft> b \<triangleright> false = (b \<and> P)"
  by (rel_auto)  
  
lemma cond_simps [simp]:
  "(\<Squnion> x \<bullet> P(x) \<triangleleft> b \<triangleright> Q(x)) \<triangleleft> b \<triangleright> R = (\<Squnion> x \<bullet> P(x)) \<triangleleft> b \<triangleright> R"
  by (rel_auto)
    
lemma [simp]: "(b \<and> P) \<triangleleft> b \<triangleright> Q = P \<triangleleft> b \<triangleright> Q"
  by (rel_auto)
    
lemma [simp]: "(b \<and> P \<triangleleft> b \<triangleright> Q) = (b \<and> P)"
  by (rel_auto)
    
thm conj_disj_distr
    
lemma cond_tr'_eq_tr_subst:
  "P \<triangleleft> $tr\<acute> =\<^sub>u $tr \<triangleright> Q = (P\<lbrakk>$tr/$tr\<acute>\<rbrakk> \<triangleleft> $tr =\<^sub>u $tr\<acute> \<triangleright> Q)"
  by (rel_auto)
    
lemma tr_eq_tr'_orient: "($tr =\<^sub>u $tr\<acute>) = ($tr\<acute> =\<^sub>u $tr)"
  by (rel_auto)
    
thm cond_assoc
    
lemma [simp]: "e =\<^sub>u e ^\<^sub>u \<langle>f\<rangle> = false"
  by (rel_auto)
    
lemma [usubst]: "\<sigma> \<dagger> (c\<cdot>v)\<^sub>u = (c\<cdot>\<sigma> \<dagger> v)\<^sub>u"
  by (rel_auto)
*)  
    

(*
lemma "(P \<and>\<^sub>p A \<and> R \<and> Q) = undefined"
  apply (pred_norm)
*)    
  
lemma unrest_chan_apply [unrest]: "x \<sharp> e \<Longrightarrow> x \<sharp> (c\<cdot>e)\<^sub>u"
  by (rel_auto)

lemma usubst_chan_apply [usubst]: "\<sigma> \<dagger> (c\<cdot>v)\<^sub>u = (c\<cdot>\<sigma> \<dagger> v)\<^sub>u"
  by (rel_auto)

    
lemma [simp]: "(P \<and>\<^sub>p Q \<and> R \<and> \<not> P) = false"
  by (pred_auto)

lemma [simp]: "($tr\<acute> =\<^sub>u $tr \<and> P \<and> $tr\<acute> =\<^sub>u $tr ^\<^sub>u \<langle>e\<rangle> \<and> Q) = false"
  by (rel_auto)
    
lemma action_tr_assign_comp [rdes]:
  fixes P :: "('s, 'e) action"
  assumes "$ok \<sharp> P" "$wait \<sharp> P" "$ref \<sharp> P"
  shows "($tr\<acute> =\<^sub>u $tr \<and> \<lceil>\<langle>\<sigma>\<rangle>\<^sub>a\<rceil>\<^sub>S) ;; P = \<lceil>\<sigma>\<rceil>\<^sub>S\<^sub>\<sigma> \<dagger> P"
  using assms by (rel_auto, meson)
    
declare prod_vwb_lens [simp]
    
lemma st_qual_alpha [alpha]: "x ;\<^sub>L fst\<^sub>L ;\<^sub>L st \<times>\<^sub>L st = ($st:x)\<^sub>v"
  by (metis (no_types, hide_lams) in_var_def in_var_prod_lens lens_comp_assoc st_vwb_lens vwb_lens_wb)
  
lemma st_subst_var:
  "\<sigma>($st:x \<mapsto>\<^sub>s \<guillemotleft>v\<guillemotright>) \<dagger> \<lceil>P\<rceil>\<^sub>S\<^sub>< = \<sigma> \<dagger> \<lceil>P\<lbrakk>\<guillemotleft>v\<guillemotright>/&x\<rbrakk>\<rceil>\<^sub>S\<^sub><"
  by (rel_auto)  
    
lemma "a \<^bold>\<rightarrow> Chaos \<sqsubseteq> a \<^bold>\<rightarrow> b \<^bold>\<rightarrow> Stop"
  by (rdes_refine, rel_auto)
    
thm alpha
 
definition "DF(A) = (\<mu>\<^sub>C X \<bullet> (\<Sqinter> a\<in>A \<bullet> a \<^bold>\<rightarrow> Skip) ;; X)"
 
lemma DF_CSP [closure]: "A \<noteq> {} \<Longrightarrow> DF(A) is CSP"
  by (simp add: DF_def closure unrest)
  
lemma preR_DF [rdes]:
  "A \<noteq> {} \<Longrightarrow> pre\<^sub>R(DF(A)) = true"
  by (simp add: DF_def rdes closure unrest wp usubst)
  
lemma periR_UINF_member [rdes]: "peri\<^sub>R(\<Sqinter> i\<in>A \<bullet> P(i)) = (\<Sqinter> i\<in>A \<bullet> peri\<^sub>R(P(i)))"
  by (rel_auto)
    
lemma periR_UINF_member_2 [rdes]: "peri\<^sub>R(\<Sqinter> (i,j)\<in>A \<bullet> P i j) = (\<Sqinter> (i,j)\<in>A \<bullet> peri\<^sub>R(P i j))"
  by (rel_auto)

lemma periR_UINF_member_3 [rdes]: "peri\<^sub>R(\<Sqinter> (i,j,k)\<in>A \<bullet> P i j k) = (\<Sqinter> (i,j,k)\<in>A \<bullet> peri\<^sub>R(P i j k))"
  by (rel_auto)

lemma postR_UINF_member [rdes]: "post\<^sub>R(\<Sqinter> i\<in>A \<bullet> P(i)) = (\<Sqinter> i\<in>A \<bullet> post\<^sub>R(P(i)))"
  by (rel_auto)

lemma postR_UINF_member_2 [rdes]: "post\<^sub>R(\<Sqinter> (i,j)\<in>A \<bullet> P i j) = (\<Sqinter> (i,j)\<in>A \<bullet> post\<^sub>R(P i j))"
  by (rel_auto)

lemma tr_ext_seqr:
  fixes P :: "('s, 'e) action"
  assumes "$ok \<sharp> P" "$wait \<sharp> P" "$ref \<sharp> P"
  shows "($tr\<acute> =\<^sub>u $tr ^\<^sub>u \<langle>\<guillemotleft>a\<guillemotright>\<rangle> \<and> $st\<acute> =\<^sub>u $st) ;; P = P\<lbrakk>$tr ^\<^sub>u \<langle>\<guillemotleft>a\<guillemotright>\<rangle>/$tr\<rbrakk>"
  using assms
  by (rel_auto, meson)
    
lemma periR_DF_lemma:
  fixes P :: "('s, 'e) action"
  assumes "$ok \<sharp> P" "$wait \<sharp> P" "$ref \<sharp> P"
  shows "(\<Sqinter> a \<in> A \<bullet> $tr\<acute> =\<^sub>u $tr ^\<^sub>u \<langle>\<guillemotleft>a\<guillemotright>\<rangle> \<and> $st\<acute> =\<^sub>u $st) \<^bold>^ i ;; P = 
         ($tr \<le>\<^sub>u $tr\<acute> \<and> elems\<^sub>u(tt) \<subseteq>\<^sub>u \<guillemotleft>A\<guillemotright> \<and> #\<^sub>u(tt) =\<^sub>u \<guillemotleft>i\<guillemotright> \<and> $st\<acute> =\<^sub>u $st) ;; P"
proof (induct i)
  case 0
  with assms show ?case
    apply (simp, rel_auto)
    apply (metis (no_types, hide_lams) list.set(1) minus_cancel order_bot_class.bot.extremum order_refl)
    apply (metis (no_types, lifting) less_eq_list_def strict_prefix_diff_minus)
  done
next
  case (Suc i)
  show ?case 
    apply (simp add: seqr_assoc[THEN sym] seq_UINF_distr tr_ext_seqr unrest usubst Suc)
    apply (rel_auto)
    apply (rename_tac tr st ok wait tr' st' ref x ok' wait' tr'' ref')
    apply (rule_tac x="ok'" in exI)
    apply (rule_tac x="wait'" in exI)
     apply (rule_tac x="tr''" in exI)
    apply (auto)
    using list_append_prefixD apply blast
    apply (auto simp add: less_eq_list_def prefix_def)[1]
      apply (metis append_Cons append_Nil append_minus list_concat_minus_list_concat subsetCE)
    apply (auto simp add: less_eq_list_def prefix_def)[1]
    apply (metis append_Cons append_Nil append_minus list_concat_minus_list_concat)      
    apply (rename_tac tr st ok wait tr' st' ref ok' wait' tr'' ref')
    apply (rule_tac x="hd(tr'' - tr)" in exI)
    apply (auto)
    apply (rule_tac x="ok'" in exI)
     apply (rule_tac x="wait'" in exI)
     apply (rule_tac x="tr''" in exI)      
    apply (auto)
    apply (metis Prefix_Order.Cons_prefix_Cons Prefix_Order.Nil_prefix Prefix_Order.same_prefix_prefix hd_Cons_tl length_greater_0_conv less_eq_list_def prefix_concat_minus zero_less_Suc)
    apply (auto simp add: less_eq_list_def prefix_def)[1]
    apply (metis Suc_length_conv append_Cons append_Nil append_minus hd_Cons_tl list.distinct(1) list_concat_minus_list_concat set_subset_Cons subsetCE)
    apply (auto simp add: less_eq_list_def prefix_def)[1]
    apply (metis Suc_length_conv append_Nil append_one_prefix cancel_comm_monoid_add_class.diff_zero diff_Suc_Suc length_drop list.sel(1) list.size(3) list_concat_minus_list_concat minus_list_def nth_Cons_0 prefix_code(1) zero_less_Suc)
    apply (metis contra_subsetD hd_in_set length_greater_0_conv zero_less_Suc)
  done
qed

lemma periR_DF [rdes]:
  "A \<noteq> {} \<Longrightarrow> peri\<^sub>R(DF(A)) = ($tr \<le>\<^sub>u $tr\<acute> \<and> elems\<^sub>u(tt) \<subseteq>\<^sub>u \<guillemotleft>A\<guillemotright> \<and> (\<^bold>\<exists> a \<in> \<guillemotleft>A\<guillemotright> \<bullet> \<guillemotleft>a\<guillemotright> \<notin>\<^sub>u $ref\<acute>))"
  apply (simp add: DF_def rdes closure unrest wp usubst alpha)  
  apply (simp add: seq_UINF_distr periR_DF_lemma unrest)
  apply (rel_auto)
done
    
lemma postR_DF [rdes]:
  "A \<noteq> {} \<Longrightarrow> post\<^sub>R(DF(A)) = false"
  by (simp add: DF_def rdes closure unrest wp usubst alpha)
    
lemma "DF(UNIV) \<sqsubseteq> (\<mu>\<^sub>C X \<bullet> (a \<^bold>\<rightarrow> Skip) ;; X)"
  apply (rule_tac mu_csp_basic_refine)
        apply (simp_all add: closure rdes wp usubst alpha)
  apply (rel_auto)
  apply (rel_simp)
  using list_append_prefixD by blast
    
lemma aext_case_prod [alpha]:
  "case_prod P v \<oplus>\<^sub>u a = case_prod (\<lambda> x y. P x y \<oplus>\<^sub>u a) v"
  by (simp add: case_prod_beta')

lemma
  assumes 
    "P is NCSP" "Q is CSP" "P is Productive" "pre\<^sub>R(P) = true" "pre\<^sub>R(Q) = true" "post\<^sub>R(Q) = false"
    "peri\<^sub>R P \<sqsubseteq> peri\<^sub>R Q"
    "peri\<^sub>R P \<sqsubseteq> post\<^sub>R Q ;; peri\<^sub>R P"
  shows "(\<mu>\<^sub>C X \<bullet> P ;; X) \<sqsubseteq> Q"
  apply (rule_tac SRD_refine_intro)
  apply (simp_all add: closure assms)
  apply (simp_all add: rdes assms closure wp seq_UINF_distr)

    
lemma 
  assumes "

"(\<mu>\<^sub>C X \<bullet> P(X)) \<sqsubseteq> Q"
  
lemma "`peri\<^sub>R(Timer ct hc tN) \<and> $tr\<acute> =\<^sub>u $tr \<Rightarrow> \<guillemotleft>step(ct,hc)\<guillemotright> \<notin>\<^sub>u $ref\<acute>`"
  apply (simp add: Timer_def)
  apply (subst csp_mu_unfold)
  apply (simp add: closure)
  apply (simp add: rdes closure unrest usubst alpha case_prod_beta' wp outp_constraint_def)
  apply (simp add: cond_def outp_constraint_def conj_disj_distr ac_simps seqr_or_distr  alpha)
(*
  apply (rel_auto)
  apply (simp add: conj_assoc cond_assoc conj_disj_distr)
  apply (simp add: outp_constraint_def alpha unrest)
  apply (simp add: cond_tr'_eq_tr_subst usubst unrest)
  *)
  

end